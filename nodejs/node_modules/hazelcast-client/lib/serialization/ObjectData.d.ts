/// <reference types="node" />
/// <reference types="long" />
import * as Long from 'long';
import { Data, DataInput, DataOutput, PositionalDataOutput } from './Data';
import { SerializationService } from './SerializationService';
export declare class ObjectDataOutput implements DataOutput {
    protected buffer: Buffer;
    protected bigEndian: boolean;
    private service;
    private pos;
    constructor(length: number, service: SerializationService, isBigEndian: boolean);
    clear(): void;
    isBigEndian(): boolean;
    position(newPosition?: number): number;
    toBuffer(): Buffer;
    write(byte: number | Buffer): void;
    writeBoolean(val: boolean): void;
    writeBooleanArray(val: boolean[]): void;
    writeByte(byte: number): void;
    writeByteArray(bytes: number[]): void;
    writeBytes(bytes: string): void;
    writeChar(char: string): void;
    writeCharArray(chars: string[]): void;
    writeChars(chars: string): void;
    writeData(data: Data): void;
    writeDouble(double: number): void;
    writeDoubleArray(doubles: number[]): void;
    writeFloat(float: number): void;
    writeFloatArray(floats: number[]): void;
    writeInt(int: number): void;
    writeIntBE(int: number): void;
    writeIntArray(ints: number[]): void;
    writeLong(long: Long): void;
    writeLongArray(longs: Long[]): void;
    writeObject(object: any): void;
    writeShort(short: number): void;
    writeShortArray(shorts: number[]): void;
    writeUTF(val: string): void;
    writeUTFArray(val: string[]): void;
    writeZeroBytes(count: number): void;
    private available();
    private ensureAvailable(size);
    private writeArray(func, arr);
}
export declare class PositionalObjectDataOutput extends ObjectDataOutput implements PositionalDataOutput {
    pwrite(position: number, byte: number | Buffer): void;
    pwriteBoolean(position: number, val: boolean): void;
    pwriteByte(position: number, byte: number): void;
    pwriteChar(position: number, char: string): void;
    pwriteDouble(position: number, double: number): void;
    pwriteFloat(position: number, float: number): void;
    pwriteInt(position: number, int: number): void;
    pwriteIntBE(position: number, int: number): void;
    pwriteLong(position: number, long: Long): void;
    pwriteShort(position: number, short: number): void;
}
export declare class ObjectDataInput implements DataInput {
    private buffer;
    private offset;
    private service;
    private bigEndian;
    private pos;
    constructor(buffer: Buffer, offset: number, serializationService: SerializationService, isBigEndian: boolean);
    isBigEndian(): boolean;
    position(newPosition?: number): number;
    read(pos?: number): number;
    readBoolean(pos?: number): boolean;
    readBooleanArray(pos?: number): boolean[];
    readByte(pos?: number): number;
    readByteArray(pos?: number): number[];
    readChar(pos?: number): string;
    readCharArray(pos?: number): string[];
    readData(): Data;
    readDouble(pos?: number): number;
    readDoubleArray(pos?: number): number[];
    readFloat(pos?: number): number;
    readFloatArray(pos?: number): number[];
    readInt(pos?: number): number;
    readIntArray(pos?: number): number[];
    readLong(pos?: number): Long;
    readLongArray(pos?: number): Long[];
    readObject(): any;
    readShort(pos?: number): number;
    readShortArray(pos?: number): number[];
    readUnsignedByte(pos?: number): number;
    readUnsignedShort(pos?: number): number;
    readUTF(pos?: number): string;
    readUTFArray(pos?: number): string[];
    reset(): void;
    skipBytes(count: number): void;
    readCopy(other: Buffer, numBytes: number): void;
    available(): number;
    private readArray<T>(func, pos?);
    private assertAvailable(numOfBytes, pos?);
    private addOrUndefined(base, adder);
}
