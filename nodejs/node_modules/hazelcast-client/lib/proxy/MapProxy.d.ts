/// <reference types="bluebird" />
import * as Promise from 'bluebird';
import { Aggregator } from '../aggregation/Aggregator';
import { EntryView } from '../core/EntryView';
import { MapListener } from '../core/MapListener';
import { Predicate } from '../core/Predicate';
import { ReadOnlyLazyList } from '../core/ReadOnlyLazyList';
import { Data } from '../serialization/Data';
import { IdentifiedDataSerializable, Portable } from '../serialization/Serializable';
import { BaseProxy } from './BaseProxy';
import { IMap } from './IMap';
export declare class MapProxy<K, V> extends BaseProxy implements IMap<K, V> {
    aggregate<R>(aggregator: Aggregator<R>): Promise<R>;
    aggregateWithPredicate<R>(aggregator: Aggregator<R>, predicate: Predicate): Promise<R>;
    executeOnKeys(keys: K[], entryProcessor: IdentifiedDataSerializable | Portable): Promise<any[]>;
    executeOnKey(key: K, entryProcessor: IdentifiedDataSerializable | Portable): Promise<V>;
    executeOnEntries(entryProcessor: IdentifiedDataSerializable | Portable, predicate?: Predicate): Promise<Array<[K, V]>>;
    entrySetWithPredicate(predicate: Predicate): Promise<any[]>;
    keySetWithPredicate(predicate: Predicate): Promise<K[]>;
    valuesWithPredicate(predicate: Predicate): Promise<ReadOnlyLazyList<V>>;
    addEntryListenerWithPredicate(listener: MapListener<K, V>, predicate: Predicate, key: K, includeValue: boolean): Promise<string>;
    containsKey(key: K): Promise<boolean>;
    containsValue(value: V): Promise<boolean>;
    put(key: K, value: V, ttl?: number): Promise<V>;
    putAll(pairs: Array<[K, V]>): Promise<void>;
    get(key: K): Promise<V>;
    remove(key: K, value?: V): Promise<V>;
    size(): Promise<number>;
    clear(): Promise<void>;
    isEmpty(): Promise<boolean>;
    getAll(keys: K[]): Promise<any[]>;
    delete(key: K): Promise<void>;
    entrySet(): Promise<any[]>;
    evict(key: K): Promise<boolean>;
    evictAll(): Promise<void>;
    flush(): Promise<void>;
    lock(key: K, ttl?: number): Promise<void>;
    isLocked(key: K): Promise<boolean>;
    unlock(key: K): Promise<void>;
    forceUnlock(key: K): Promise<void>;
    keySet(): Promise<K[]>;
    loadAll(keys?: K[], replaceExistingValues?: boolean): Promise<void>;
    putIfAbsent(key: K, value: V, ttl?: number): Promise<V>;
    putTransient(key: K, value: V, ttl?: number): Promise<void>;
    replace(key: K, newValue: V): Promise<V>;
    replaceIfSame(key: K, oldValue: V, newValue: V): Promise<boolean>;
    set(key: K, value: V, ttl?: number): Promise<void>;
    values(): Promise<ReadOnlyLazyList<V>>;
    getEntryView(key: K): Promise<EntryView<K, V>>;
    addIndex(attribute: string, ordered: boolean): Promise<void>;
    tryLock(key: K, timeout?: number, lease?: number): Promise<boolean>;
    tryPut(key: K, value: V, timeout: number): Promise<boolean>;
    tryRemove(key: K, timeout: number): Promise<boolean>;
    addEntryListener(listener: MapListener<K, V>, key: K, includeValue?: boolean): Promise<string>;
    removeEntryListener(listenerId: string): Promise<boolean>;
    protected executeOnKeyInternal(keyData: Data, proData: Data): Promise<V>;
    protected containsKeyInternal(keyData: Data): Promise<boolean>;
    protected putInternal(keyData: Data, valueData: Data, ttl: number): Promise<V>;
    protected putAllInternal(partitionsToKeysData: {
        [id: string]: Array<[Data, Data]>;
    }): Promise<void>;
    protected getInternal(keyData: Data): Promise<V>;
    protected removeInternal(keyData: Data, value?: V): Promise<V>;
    protected getAllInternal(partitionsToKeys: {
        [id: string]: any;
    }, result?: any[]): Promise<Array<[Data, Data]>>;
    protected deleteInternal(keyData: Data): Promise<void>;
    protected evictInternal(keyData: Data): Promise<boolean>;
    protected putIfAbsentInternal(keyData: Data, valueData: Data, ttl: number): Promise<V>;
    protected putTransientInternal(keyData: Data, valueData: Data, ttl: number): Promise<void>;
    protected replaceInternal(keyData: Data, newValueData: Data): Promise<V>;
    protected replaceIfSameInternal(keyData: Data, oldValueData: Data, newValueData: Data): Promise<boolean>;
    protected setInternal(keyData: Data, valueData: Data, ttl: number): Promise<void>;
    protected tryPutInternal(keyData: Data, valueData: Data, timeout: number): Promise<boolean>;
    protected tryRemoveInternal(keyData: Data, timeout: number): Promise<boolean>;
    private addEntryListenerInternal(listener, predicate, key, includeValue);
    private createEntryListenerToKey(name, keyData, includeValue, flags);
    private createEntryListenerToKeyWithPredicate(name, keyData, predicateData, includeValue, flags);
    private createEntryListenerWithPredicate(name, predicateData, includeValue, flags);
    private createEntryListener(name, includeValue, flags);
    private checkNotPagingPredicate(v);
}
